## 操作系统总结

操作系统屏蔽了硬件层的复杂性，os的内核是os的核心部分，他负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理等，内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性

### 系统调用

根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：

1.用户态：用户态运行的进程可以直接读取用户程序的数据

2.内核态：内核态可以简单的理解为内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制

我们运行的程序基本都是运行在用户态，如果在应用程序中需要调用系统提供的内核态级别的子功能，那么就需要系统调用

也就是说我们的应用程序，凡是和内核态级别的资源有关的操作（如文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代替完成

系统调用大致分为以下几类：

1.设备管理，完成设备的请求或者释放，以及设备启动等功能

2.文件管理：完成文件的读写，创建和删除等操作

3.进程控制：完成进程的创建，撤销，阻塞及唤醒等功能

4.进程通信：完成进程间的信号传递和信息传递等功能

5.内存管理：完成内存的分配，回收以及获取作业占用内存区大小及地址等功能

### 进程和线程

一个进程可以有多个线程，多个线程共享进程的一些资源，拿jvm运行时数据区举例，启动一个springboot项目，用jvisualvm来看的话，每一个微服务对应一个进程，每一个微服务有自己的进程id，点击去观察，可以看到正在运行的所有线程。那么拿os的角度来说就是线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程，线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位，还是以jvm来举例，启动一个springboot项目，划分好初始堆和最大堆大小后，那么操作系统就为这个进程分配好了设定的资源，那么每一个请求过来以后可以看做是一个线程，线程有它自己的私有区域，当然也可以共享进程中的资源，而一次会话的执行链路，是一个线程去做真正的执行调用，所以线程可以看做是程序执行的最小单位

### 进程的状态

进程的状态分为五种：

1.创建状态：进程正在被创建，尚未到就绪状态

2.就绪状态：进程已经处于准备运行状态，即这个进程已经获得了除cpu以后的其他所有资源，一旦得到处理器资源，进程就可以运行了，所谓的得到处理器资源就是得到cpu的时间分片

3.运行状态：进程正在处理器上运行

4.阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，比如等待io操作的完成

5.结束状态：进程停止，可能正常结束，也可能其他原因中断退出

### 进程间的通信方式

每个进程都有自己的不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝内核缓冲区，进程2再从内核缓冲区把数据读走，由内核来提供这种交换数据的机制，这种机制就叫做进程间的通信

1.管道，或者匿名管道

管道是半双工的，数据只能向一个方向流动，需要双方通信的时候，需要建立两个管道，并且匿名管道只能用于父子进程或者兄弟进程，也就是具有亲缘关系的进程，管道它单独构成一个文件系统，这个内核中的管道对于两边的进程来说，就是一个文件，但它不是普通的文件，是单独构成的一个文件系统，只存在于内存之中，并且管道可以看成是一个队列，一个进程向管道的一端写入内容，新写入的内容在队列的尾部，读取是从管道的头部开始读取

2.有名管道

匿名管道由于没有名字，只能用于亲缘关系的进程间通信，为了克服这个缺点，提出了有名管道，有名管道和匿名管道的最大不同就是它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样与有名管道的创建进程不存在关系的进程也快可以和他通信。有名管道以磁盘文件的形式存在，可以实现本机任意两个进程通信

有名管道的定义存在于文件系统中，内容存放在内存中，内存中还是一个先入先出的队列结构，对数据的读取还是从对头，对数据的写入则是添加在队尾

3.信号

信号是linux系统中用于进程间相互通信的一种机制，信号可以在任意时刻发送给某一进程，而无需知道该进程的状态

如果该进程当前并未处于执行状态，则该信号将会被保存起来，直到该进程恢复执行并传递给它为止

**Linux系统中常用信号：**
 （1）**SIGHUP：**用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
 （2）**SIGINT：**程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
 （3）**SIGQUIT：**程序退出信号。程序运行过程中，按`Ctrl+\\`键将产生该信号。
 （4）**SIGBUS和SIGSEGV：**进程访问非法地址。
 （5）**SIGFPE：**运算中出现致命错误，如除零操作、数据溢出等。
 （6）**SIGKILL：**用户终止进程执行信号。shell下执行`kill -9`发送该信号。
 （7）**SIGTERM：**结束进程信号。shell下执行`kill 进程pid`发送该信号。
 （8）**SIGALRM：**定时器信号。
 （9）**SIGCLD：**子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

信号是软件层次上对中断机制的一种模拟，是一种异步的通信的方式，信号可以在用户空间进程和内核之间直接交互

信号的来源主要有两个：

1.硬件来源，用户键入ctrl + c等

2.软件终止，终止进程信号，比如其他进程调用kill函数等

信号一般由一个进程发起，并设置此信号传递的对象，一般就是对应的进程id

4.消息队列

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示

与管道（匿名管道存放在内存中，有名管道存在实际的磁盘中）不同的是消息队列存放在内核中，只有在内核重启，即os重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除

消息队列可以实现消息的随机查询，消息不一定要以先进先出的顺序读取，也可以按照消息的类型来读取

5.共享内存

使得多个进程可以直接读写同一块内存空间，是针对其他通信机制运行效率较低而设计的，为了在多个进程间交互信息，内核专门留出了一块内存空间，可以由需要访问的进程将其映射到自己的私有内存空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

6.信号量

信号量也是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间的同步

**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。

**等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作

**挂出一个信号量**：该操作将信号量的值加1，也称为V操作

信号量和互斥量之间的区别：

互斥量用于线程的互斥，信号量用于线程的同步。

互斥：是指某一资源同一时刻只允许一个访问者对其访问，具有唯一性和排他性，但互斥无法限制访问者的访问顺序，即访问是无序的

同步：是指在互斥的基础上，通过其他机制来实现访问者对资源的顺序访问

大多数情况的同步肯定已经实现了互斥，尤其是对于写操作必定是互斥的

7.套接字：

套接字可以让不在一台计算机上的不同进程之间通过网络进程通信

套接字是支持tcp/ip的网络通信的基本操作单元。

套接字的特性由三个属性完成：分别是，域，端口，协议

最常见的套接字域有两种：internet网络，当客户使用套接字进行跨网络的连接时，它就需要使用服务器的ip地址和端口号来指定一台互联网机器上的某一个应用进程，所以在使用socket作为通信的终点，服务端应用程序应该开始通信之前绑定一个端口，服务器在指定的端口等待客户端的连接

另一个域就是unix文件系统，他就是文件的输入和输出，它的地址就是文件名

套接字的使用：

首先服务端应用程序通过系统调用socket来创建一个套接字，他是系统分配给服务器进程的类似文件描述符的资源，他不能与其他进程共享

然后服务器进程会给套接字起一个名字，使用bind来给套接字命名，然后服务器进程就开始等待客户连接到这个套接字

就下来系统调用listen来创建一个队列用于存放来自客户端的连接

最后服务器通过调用accept来接收客户的连接

客户端首先调用socket创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接

一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信

### 数据库的三大范式的理解

第一范式：每一列的属性都是不可再被分割的属性值，确保每一列的原子性，两列属性相近的或相似或一样的列，尽量合并属性一样的列，确保不产生冗余的数据

比如一张表，有一个列叫做地址，如果我有一个需求需要按照省市区进行分类，那么这样子建表是不容易满足需求的，不满足第一范式

因为它可以再被分为省，市，区三个列，而且这三个列还都不是相近的，什么叫相近，比如存储物品，我在这个表里面建立物品1字段，物品1数量，物品1价格，物品2字段。。。

显然这种方式的建表不能满足足够多的商品数量，也无法满足第一范式

第二范式：每一行数据只能与其中一列相关，即一行数据只做一件事情，只要数据列中出现数据重复，就要把表拆分开来

第二范式在第一范式的基础之上，确保数据库表中每一列都和主键相关，而不能只和某一部分主键进行关联，其实针对的是联合主键的情况，也就是说在一个表中，只保存一种数据，不可以把多种数据保存在一个表中

有一个订单表，有一个主键订单id，还有一个主键是商品id，后面就是商品编号，单位，价格，购买人姓名，联系电话等

那么这个问题就很明显了，这个表是一个订单主键与商品编号主键的联合主键，后面的商品信息只跟商品编号相关，跟订单id并没有任何关系，这个商品可以出现在任何一个订单中，那么做法就是分表，订单表中只有一个主键，那就是订单id，然后维护维护一下购买者信息就行了，然后维护一张订单项目表，在订单项表中，存储了跟这个订单项有关的商品id，然后再维护商品信息表，商品id作为主键，存储这个商品的详细信息。

第三范式：数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系

假设有一个student表，里面有学号，姓名，性别，所在院校，院校地址，院校电话

这样一个表结构的话，就存在学号对应院校，院校对应院校地址和院校电话这种情况

对于这种情况，我们应该将其拆分出来，跟学生相关的就放在一个表中，院校放在另外一个表中。

范式只是设计数据库的基本理念，根据范式可以建立出冗余较小，结构合理的数据库，但是根据特殊业务一定要特殊对待

### SQL注入

只要是支持批处理SQL指令的数据库服务，都有可能受到sql注入的攻击

注入的本质就是把用户的输入的数据作为代码来执行了，有两个关键条件，第一个是用户能控制输入，第二个是原本程序要执行的代码，拼接了用户输入的数据，把数据当代码执行了

sql注入攻击是指通过构造特殊的输入作为参数传入到web程序中，而这些输入大都是sql语法里的一些组合，通过执行sql语句进而执行攻击者所要执行的操作，其主要原因是程序没有细致的过滤用户输入的数据致使非法数据侵入系统

防御sql注入的方式：
最佳方法就是预编译语句，绑定变量，使用预编译的sql语句，sql的语义不会变化，攻击者无法改变sql的结构

~~~wiki
但凡有sql注入的程序，都是因为程序需要接收来自客户端用户输入的变量或者url传递的参数，并且这个变量或参数是组成sql语句的一部分，对于用户的输入的内容或者传递的参数，我们应该保持警惕
最好的办法是绑定变量，使用预编译语句
实际上绑定变量使用预编译语句是预防sql注入的最佳方式，使用预编译的sql语句语义不会发生变化，在sql语句中，变量用？表示，这样无法怎么样sql的结构都不会被改变
~~~

sql预编译：

通常一条普通的sql语句执行的过程是：

1.词法分析和语法分析

2.优化sql语句，制定执行计划

3.执行并返回结果

~~~wiki
一条sql语句的执行流程：
客户端发给连接器，连接器管理连接，权限验证
连接建立会走查询缓存，查询缓存是一个不建议使用的功能，因为一旦有一个对该表的更新，那么这个表上的查询缓存都会被清空，对于热表来说，查询缓存的命中率极低，到了mysql8.0以后也已经把这个功能删掉了
接下来走分析器，分析器做词法分析和语法分析
接下来是优化器，生成执行计划，选择合适的索引
执行器，调用存储引擎的接口，等待存储引擎向其返回结果
存储引擎提供数据的读写功能接口
~~~

我们把这种普通语句称作Immediate Statements（当前报表）

但是很多情况下，一条sql语句会被反复的执行，或者每次执行的时候只有个别的值不同，比如select的where子句不同，update的set子句不同，insert的values不同，如果每次都要经过上面那些执行步骤，那么效率是非常慢的。

所谓的预编译就是把sql语句模板化或者叫参数化，对那些变化的参数用占位符替代，这类语句被叫做Prepared Statements

预编译除了能优化性能外，最大的好处是防止sql注入

简单说就是参数化能防止注入的原因就是，语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按照语句的语义跑，至于参数是什么，不会有方向上的影响，只会有快慢的影响

mybatis的#和$的区别：

#是将传入的数据当成一个字符串，会对传入的数据自动加上一个双引号

$是将传入的数据直接显示生成在sql语句中，也就是拼接以后会成为sql语句的一部分

比如：用户传入的数据是"; drop table t_user;"select * from t_user where username = ;drop table t_user;

#可以防止sql注入

底层原理就是mybatis底层使用jdbc的PreparedStatement，PreparedStatement对象包含了编译好的sql语句，这种准备好的方式预防sql注入，而且多次执行同一个sql的时候，能够提高效率，因为sql已经提前编译好，再次执行的时候无需进行编译了

### 一致性哈希

首先我来说一下一致性哈希解决的问题：在分布式系统中由于cap理论的p，也就是分区容错性，是一定保证的，也就是说发生了网络分区或者节点故障的时候，服务器还要能对外提供服务。那么考虑到分布式系统中的每个节点都有可能失效，并且新的节点也可能会动态的增加进来，所在在分布式系统，尤其是分布式缓存系统中，如果某台服务器失效了，对于整个系统来说如果不采用一个合适的算法来保证一致性的话，那么缓存的命中率可能会急剧下降

一致性哈希将整个哈希值空间组织成一个虚拟的圆环，然后它的取值范围是0-2的31次方减一，也就是一个32位无符号的整型

整个空间按照顺时针方向组织，然后将各个服务器进行一个hash，具体可以选择服务器ip或者主机名等关键字来进行哈希，这样每台机器首先可以在这个哈希环上确定它的位置，接了来使用一定的算法定位数据访问到相应的服务器上，然后计算数据的key来算出一个哈希值，确定了这个数据在这个哈希环上的位置了，然后会从这个位置开始顺时针方向向前面寻找一个最近的服务器，第一个遇到的服务器就是这个数据应该定位的服务器。一致性哈希最主要的是可扩展性和容错性

假设在这个环中，有一个服务器节点宕机了，只会造成在这个节点以前到上一个节点之间的数据受到影响，其他不会受到影响

增加一台节点也是一样的，只会影响沿着逆时针方向往回寻找的第一台服务器之间的数据。

所以一致性哈希算法对于节点的增减都只需要重定位环中一小部分的数据就ok了，具有良好的容错性和可扩展性

另外如果节点数量过少的话，容易因为节点分布的不均匀而导致数据倾斜的问题，也就是大量数据定位到某一个节点上，而另外一个节点只有很少的数据，为了解决这种数据倾斜的问题，一致性哈希算法引入了虚拟节点或者叫副本的机制，就是对一个机器节点计算多个哈希值，每个哈希值的位置都放一个这个服务节点，这样整个环的分布整体上是均匀的，具体的做法可以在主机的ip或者主机名后面加个编号来实现，这样的话数据的定位算法其实是不变的，只是多了一步虚拟节点到真实节点的映射，假设这个数据前面的第一个服务器节点是某一个服务器的虚拟节点的话，那么它会映射到真实的节点上去，这是一致性哈希算法解决数据倾斜问题

