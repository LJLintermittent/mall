## 操作系统总结

操作系统屏蔽了硬件层的复杂性，os的内核是os的核心部分，他负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理等，内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性

### 系统调用

根据进程访问资源的特点，可以把进程在系统上的运行分为两个级别：

1.用户态：用户态运行的进程可以直接读取用户程序的数据

2.内核态：内核态可以简单的理解为内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制

我们运行的程序基本都是运行在用户态，如果在应用程序中需要调用系统提供的内核态级别的子功能，那么就需要系统调用

也就是说我们的应用程序，凡是和内核态级别的资源有关的操作（如文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代替完成

系统调用大致分为以下几类：

1.设备管理，完成设备的请求或者释放，以及设备启动等功能

2.文件管理：完成文件的读写，创建和删除等操作

3.进程控制：完成进程的创建，撤销，阻塞及唤醒等功能

4.进程通信：完成进程间的信号传递和信息传递等功能

5.内存管理：完成内存的分配，回收以及获取作业占用内存区大小及地址等功能

### 进程和线程

一个进程可以有多个线程，多个线程共享进程的一些资源，拿jvm运行时数据区举例，启动一个springboot项目，用jvisualvm来看的话，每一个微服务对应一个进程，每一个微服务有自己的进程id，点击去观察，可以看到正在运行的所有线程。那么拿os的角度来说就是线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程，线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位，还是以jvm来举例，启动一个springboot项目，划分好初始堆和最大堆大小后，那么操作系统就为这个进程分配好了设定的资源，那么每一个请求过来以后可以看做是一个线程，线程有它自己的私有区域，当然也可以共享进程中的资源，而一次会话的执行链路，是一个线程去做真正的执行调用，所以线程可以看做是程序执行的最小单位

### 进程的状态

进程的状态分为五种：

1.创建状态：进程正在被创建，尚未到就绪状态

2.就绪状态：进程已经处于准备运行状态，即这个进程已经获得了除cpu以后的其他所有资源，一旦得到处理器资源，进程就可以运行了，所谓的得到处理器资源就是得到cpu的时间分片

3.运行状态：进程正在处理器上运行

4.阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，比如等待io操作的完成

5.结束状态：进程停止，可能正常结束，也可能其他原因中断退出

### 进程间的通信方式

每个进程都有自己的不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝内核缓冲区，进程2再从内核缓冲区把数据读走，由内核来提供这种交换数据的机制，这种机制就叫做进程间的通信

1.管道，或者匿名管道

管道是半双工的，数据只能向一个方向流动，需要双方通信的时候，需要建立两个管道，并且匿名管道只能用于父子进程或者兄弟进程，也就是具有亲缘关系的进程，管道它单独构成一个文件系统，这个内核中的管道对于两边的进程来说，就是一个文件，但它不是普通的文件，是单独构成的一个文件系统，只存在于内存之中，并且管道可以看成是一个队列，一个进程向管道的一端写入内容，新写入的内容在队列的尾部，读取是从管道的头部开始读取

2.有名管道

匿名管道由于没有名字，只能用于亲缘关系的进程间通信，为了克服这个缺点，提出了有名管道，有名管道和匿名管道的最大不同就是它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样与有名管道的创建进程不存在关系的进程也快可以和他通信。有名管道以磁盘文件的形式存在，可以实现本机任意两个进程通信

有名管道的定义存在于文件系统中，内容存放在内存中，内存中还是一个先入先出的队列结构，对数据的读取还是从对头，对数据的写入则是添加在队尾

3.信号

信号是linux系统中用于进程间相互通信的一种机制，信号可以在任意时刻发送给某一进程，而无需知道该进程的状态

如果该进程当前并未处于执行状态，则该信号将会被保存起来，直到该进程恢复执行并传递给它为止

**Linux系统中常用信号：**
 （1）**SIGHUP：**用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
 （2）**SIGINT：**程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
 （3）**SIGQUIT：**程序退出信号。程序运行过程中，按`Ctrl+\\`键将产生该信号。
 （4）**SIGBUS和SIGSEGV：**进程访问非法地址。
 （5）**SIGFPE：**运算中出现致命错误，如除零操作、数据溢出等。
 （6）**SIGKILL：**用户终止进程执行信号。shell下执行`kill -9`发送该信号。
 （7）**SIGTERM：**结束进程信号。shell下执行`kill 进程pid`发送该信号。
 （8）**SIGALRM：**定时器信号。
 （9）**SIGCLD：**子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

信号是软件层次上对中断机制的一种模拟，是一种异步的通信的方式，信号可以在用户空间进程和内核之间直接交互

信号的来源主要有两个：

1.硬件来源，用户键入ctrl + c等

2.软件终止，终止进程信号，比如其他进程调用kill函数等

信号一般由一个进程发起，并设置此信号传递的对象，一般就是对应的进程id

4.消息队列

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示

与管道（匿名管道存放在内存中，有名管道存在实际的磁盘中）不同的是消息队列存放在内核中，只有在内核重启，即os重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除

消息队列可以实现消息的随机查询，消息不一定要以先进先出的顺序读取，也可以按照消息的类型来读取

5.共享内存

使得多个进程可以直接读写同一块内存空间，是针对其他通信机制运行效率较低而设计的，为了在多个进程间交互信息，内核专门留出了一块内存空间，可以由需要访问的进程将其映射到自己的私有内存空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

6.信号量

信号量也是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间的同步

**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。

**等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作

**挂出一个信号量**：该操作将信号量的值加1，也称为V操作

信号量和互斥量之间的区别：

互斥量用于线程的互斥，信号量用于线程的同步。

互斥：是指某一资源同一时刻只允许一个访问者对其访问，具有唯一性和排他性，但互斥无法限制访问者的访问顺序，即访问是无序的

同步：是指在互斥的基础上，通过其他机制来实现访问者对资源的顺序访问

大多数情况的同步肯定已经实现了互斥，尤其是对于写操作必定是互斥的

7.套接字：

套接字可以让不在一台计算机上的不同进程之间通过网络进程通信

套接字是支持tcp/ip的网络通信的基本操作单元。

套接字的特性由三个属性完成：分别是，域，端口，协议

最常见的套接字域有两种：internet网络，当客户使用套接字进行跨网络的连接时，它就需要使用服务器的ip地址和端口号来指定一台互联网机器上的某一个应用进程，所以在使用socket作为通信的终点，服务端应用程序应该开始通信之前绑定一个端口，服务器在指定的端口等待客户端的连接

另一个域就是unix文件系统，他就是文件的输入和输出，它的地址就是文件名

套接字的使用：

首先服务端应用程序通过系统调用socket来创建一个套接字，他是系统分配给服务器进程的类似文件描述符的资源，他不能与其他进程共享

然后服务器进程会给套接字起一个名字，使用bind来给套接字命名，然后服务器进程就开始等待客户连接到这个套接字

就下来系统调用listen来创建一个队列用于存放来自客户端的连接

最后服务器通过调用accept来接收客户的连接

客户端首先调用socket创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接

一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信





