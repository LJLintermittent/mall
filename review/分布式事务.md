### 分布式事务问题的由来

事务最简单的理解就是一手交钱一手交货，交钱和交互必须都成功，一方没有成功，那么另一方也不能成功

对于本地事务来说，一般都是由关系型数据库来保证，利用数据库本身的事务特性来实现，而对于单体应用来说，一个应用一个库，所以在一个库中就可以很方便的利用数据库来帮助完成事务，但是对于分布式微服务架构来说，通常会把一个完整的系统拆分成多个微服务子系统，每一个子系统对应一个数据库，部署在不同的机器上，每一个微服务内部只会与自己的数据库建立连接，那么你自己做回滚的话，当然可以通过自己的数据库来完成，而对于分布式系统，订单服务下单成功，需要扣减库存，增加积分，消耗京豆等，订单服务需要调用库存服务，优惠券服务等多个服务，如果订单服务自己回滚了，没有让其他服务回滚，那么造成数据的逻辑不一致

简而言之就是跨jvm进程产生了分布式事务

分布式事务之所以叫分布式，是因为提供服务的各个节点分布在不同的机器上，相互之间通过网络远程调用，不能因为一点网络问题就导致 整个系统服务错乱，数据错乱。

分布式事务名词：

TC：事务协调者，维护全局和分支事务的状态，驱动全局事务提交或者回滚

TM：事务管理者，定义全局事务的范围，也就是这个全局事务包含了哪些分支事务，开始做全局事务的提交或者回滚

RM：资源管理者，管理分支事务处理的资源，与TC交谈，注册分支事务和报告分支事务的状态，并驱动分支事务提交或者回滚

### 2PC 二阶提交

2pc即二阶提交协议，是将整个事务流程划分为两部分，准备阶段和提交阶段，2是有两个阶段，p是准备，c是提交

2pc只是一种宏观上的理论指导，只是阐述了大的方向，比如说数据库支持的XA模式就是一个2pc

二阶段提交是一种强一致性的设计，2pc引入了一个事务的协调者来协调管理各个参与者。

准备阶段，那么准备阶段可以理解为事务协调者TC会给所有的事务参与者发送准备命令，准备命令可以理解除了事务提交以外其他事情都做完了

提交阶段有点特殊，因为既可以是提交，也可以是回滚，当所有的事务参与者都提交完成了，TC，事务协调者才会最终返回成功，如果第一阶段有一个失败了，那么全部进行回滚，也就是说要想进入第二阶段，首先第一阶段得全部达成，那么第二阶段提交的时候，如果出现故障，有些事务已经提交完成，有些没有，那么只能重试，直到提交成功为止。

另外如果第二阶段执行的是回滚操作，如果回滚有些都失败了，也需要进行重试

所以大体上来看2pc是一个同步阻塞协议，像第一阶段协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的**协调者有超时机制**，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令

另外2pc有一个协调者，TC挂了怎么办？

单点协调者挂了可以拉起来一个新的协调者，但是这里会有很多的问题，比如新协调者不知道每一个事务的状态，假如上一个协调者知道A需要回滚，协调者要发送命令之前挂了，A也挂了，新协调者来了，询问每一个RM，剩下的RM都是好的 ，那么新协调者直接让他们提交了，解决办法是日志记录啊等等

总结来说2pc是一种尽量保证强一致性的分布式事务，因此他是一个同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言2pc的效率是非常低的，并且存在tc单点故障问题，极端条件下会有数据不一致的风险

另外，2pc也只适用于数据库层面的事务问题，而有些业务并不仅仅关乎数据库，也有可能是发送一条短信或者上传一张图片等

### TCC

tcc本质上是一种解决多个微服务之间的分布式事务的方案，tcc是try，confirm，cancel三个单词的缩写，其本质是一个应用层面上的2pc

同样分为两个阶段：

1）阶段一：准备阶段。协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。

2）阶段二：提交阶段。若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。

### 基于消息队列的最终一致性事务方案

无论是2pc还是3pc，事务状态表，基本都遵循XA协议的思想。即这些方案本质上都是通过事务协调者协调各个事务的进度，使所有本地事务共同提交或者回滚，最终能在执行完毕后立即达成一致性，在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令

2pc和3pc是一种强一致性事务，不过还是有数据的不一致性，阻塞等风险，而且只能用在数据库层面

而TCC是一种补偿性事务，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每个操作都需要实现对应的三个方法

本地消息表，最大努力通知其实都是柔性事务，或者叫做最终一致性事务，适用于对时间不敏感的业务，不是说对数据不敏感，数据依然很敏感，要尽最大努力来完成

但是由于这种全局事务方案由于操作繁琐，时间跨度大，并且全局事务期间会排他地的锁住相关资源，导致整个分布式系统的并发不会太高，很难满足电商系统这种高并发场景对事务吞吐量的要求，这种全局的一致性的2pc事务，适合处理需要数据强一致的分布式业务，比如说支付宝转账等，这个慢一点是可以理解的，但是一定要保证事务的ACID特性，而对于下单扣库存这种场景，它具有超高的并发量，整个过程中应该尽快将业务执行完毕，那么用消息队列实现的最终一致性全局事务就是一个经典的方案

### 消息队列

以电商系统中下订单，减库存这套业务逻辑开始分析：

用户在下单的过程中请求订单服务，订单服务需要创建订单，然后将订单写入库中，并且会调用库存服务扣减库存，正常来说这俩肯定是在一个事务中，但是又是两个微服务系统，需要使用分布式事务，而是用消息队列后：

1.订单服务向mq发送扣减库存的消息，库存服务订阅，负责消费消息

2.用户下单后，订单服务先执行插入订单的sql语句，然后将消息发给mq，这两个动作在一个本地事务内进行，一旦插入订单sql失败回滚，那么消息发给mq这个过程就不会发生，同样，如果发送消息失败，也会回滚，那么数据库中数据回滚，什么也没有发生

3.然后库存服务收到消息，先执行扣减库存的语句，然后向mq反馈消息消费完成的ack，这两个过程在一个本地事务中进行，一旦扣减库存失败，导致事务回滚，那么就不会回复ack，mq会在confirm机制下继续向库存服务推送该消息，直到整个事务成功提交

以上这种做法是有严重缺陷的，订单服务再给mq发送消息的时候如果是失败状态，可以有好几种可能，可能是mq没有收到消息，也可能是收到消息了，但是返回返回的ack由于网络故障没有被订单服务收到，那么订单服务贸然回滚，而库存还把消息给消费了，那么这两边数据就不一致了

正确的做法是：

1.订单服务向订单表添加数据，并向本地消息表中保存对应的扣减库存的消息，这两个过程在一个本地事务中完成

2.在库存服务中检查本次扣库存操作是否已经执行过，如果本次扣减库存没有执行过，那么扣减库存，写判重表，向mq反馈消息消费完成的ack，这四个操作也要在一个事务中完成

订单服务中有一个后台程序，不断的把本地消息表中的消息传送给消息中间件，成功后则删除消息表中的消息，如果失败了，会不断的重试，由于存在网络2将军问题，也就是订单服务不知道自己发出去的消息，mq是收到了还是没收到还是收到了没有ack回来，那么订单服务会再次发送消息，直到mq成功响应，这里面只要保证消息是有序的就行，但是可能会发生消息的重复消费，不要紧，只要不丢失，不乱序，后面的库存服务来做去重

3.库存服务收到消息以后，要去做扣减库存的操作，然后返回ack，mq收到ack后才会判定库存服务成功处理了这条消息，否则会重复推送这条消息，那么库存服务这边一定要做判重表

4.导致消费者重复消费的原因有两个：那么一个是生产者的重复生产，一个是mq的重传机制，为了实现业务的幂等性，消费者应该维护一张判重表，判重表里面记录的是被成功处理的消息的id，库存服务每次接收到新消息都要先判断这个消息是否被成功处理过，若是的话不再重复处理了

通过这种设计，实现了消息在发送方不丢失，在接收方不重复消费，联合起来就是消息不重不漏，最终能保证两个分布式系统之间的事务一致性

### 电商项目分布式事务与下单

首先是购物车模块，首先分析购物车的数据模型以及这种数据应该用什么来存储，首先购物车中的购物数据叫做购物项，一个购物项就是一个sku，里面包含这个sku的基本信息，单价，数量等，那么整个购物车就由多个sku购物项组成的，另外购物车肯定是一个用户一个购物车，那么可以想到redis的哈希键，首先对于redis的数据结构来说的，每一个key都是字符串键，哈希键的意思是值的哈希对象，而哈希对象底层使用字典，是一种kv，那么一个用户一个哈希键，键就是用户的唯一id，然后哈希键的key是购物项id，也叫skuid，value是这个sku的信息以及购买的数量等信息

订单这边的session共享，核心思想就是redis存储session，并且把cookie的作用域放大到*.mall.com

订单系统必然涉及到用户信息，因此进入订单系统的请求必然是已经登录了的，需要使用拦截器来对未登录的订单进行拦截。

注入一个HandlerInterceptor组件，拦截处理操作就是根据这个请求拿到session，从session中获取出用户信息，放到threadlocal里面，拦截放行，加上threadlocal是为了登录以后将用户数据放在本地内存中，在该线程接下来的操作中不需要每次都去请求redis中的session信息，用线程池执行任务的时候非主线程是没有请求数据的，可以通过RequestContextHolder.setRequestAttributes进行异步线程内部的设置，也就是在异步之前，从主线程中取出RequestAttributes，然后在每一个线程内部再设置进去就ok了

订单模块的业务逻辑：

用户在购物车中点击去结算，会把选中的商品查出来跳转到订单确认页面，这个页面用来选择收货地址，计算邮费，然后计算出订单最终的应付价格，然后点击提交订单，这个提交订单按钮会真正生成订单，然后锁定库存，那么这个接口一定要保证幂等性，也就是多次提交结果和单次提交是一致的。

#### 创建订单接口的幂等性

本项目使用token令牌机制解决接口幂等性问题，具体流程如下：

1.准备好订单确认数据后，返回给用户看一下运费等信息，当前页面是一个订单确认页，这个接口里面要提前创建防重令牌，浏览器保存一份，redis保存一份，也就是一个给用户，一个给服务器。其实就是购物车中点击去结算接口，这个接口查出所有的订单确认页需要展示的数据，然后给浏览器返回的vo中保存一份token，给redis存一份token。

2.接下来用户确认完毕以后，准备真正提交订单，去支付页面的时候，这个接口会接收前端传来的参数，参数中带有浏览器保存的那个token，与redis的token进行对比，如果对比成功那么删除redis中的令牌，这样子用户狂点，那么第一次请求成功后token就没了，比对肯定不成功，可以返回一个友好的错误页面，这就达成了业务的幂等性，验证令牌和删除令牌是一个原子操作，使用lua脚本

#### 订单链路的分布式事务

订单服务下订单，库存服务减库存，用户服务扣减积分等，组成一个分布式事务

库存服务锁定成功以后，需要给消息队列发送一个消息，这个消息是当前库存的工作单，如果用户没有在规定的时间内支付，那么订单会过期解锁，当然解锁前还要查看订单的状态。

1.远程服务假失败，远程服务其实执行成功了，由于网络故障导致数据没有返回，那么订单服务的本地事务以为你失败了，订单回滚了，库存却扣减了

2.远程服务执行完成，订单服务这边在调用远程服务下面还有服务出现问题，导致回滚，那么已经执行的远程服务没法回滚，而订单却回滚了

### raft算法

raft是一个实现分布式一致性的协议，他规定了节点的三种状态，follower，candidate，leader

那么在leader选举的过程中，所有节点首先默认都以随从状态启动，随从监听不到leader的话，那么他就是一个候选人，每个人都会给自己投票，然后告诉其他人，同时也会收到其他人的消息

在raft运行的过程中，最主要的两个活动是选举和复制

每个节点都会随机带一个计时器，当计时器结束后，这个节点状态会变为候选人状态，他会给其他节点发送请求，让他们来投票，如果超过半数的节点投了票，那么候选人就会成为领导，然后隔段时间发一个心跳检测，如果有一个leader挂了，那么剩余节点重新选主，过程类似，只不过新主回来以后变为了从

如果同时诞生了两个以上的候选人，那么最新timeout的节点会重新发起一轮投票

